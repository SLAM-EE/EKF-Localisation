!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
DT	extended_kalman_filter.py	/^DT = 0.1  # time tick [s]$/;"	v
EKF	localise_ekf.py	/^class EKF(object):$/;"	c
GPS_NOISE	extended_kalman_filter.py	/^GPS_NOISE = np.diag([0.5, 0.5]) ** 2$/;"	v
INPUT_NOISE	extended_kalman_filter.py	/^INPUT_NOISE = np.diag([1.0, np.deg2rad(30.0)]) ** 2$/;"	v
INPUT_NOISE	start_localisation.py	/^INPUT_NOISE = np.array([0.01, np.deg2rad(30)])              # input noise std$/;"	v
MAP	myrobot.py	/^    MAP = np.array([[0.0, 0.0], [1.0, 1.0]])$/;"	v	class:Robot
MAP_L	start_localisation.py	/^MAP_L = np.array(landmarks, dtype=np.float)$/;"	v
MAP_SIZE	myrobot.py	/^    MAP_SIZE = 2$/;"	v	class:Robot
Q	extended_kalman_filter.py	/^Q = np.diag([$/;"	v
Q	start_localisation.py	/^Q = np.diag([1.0, np.deg2rad(30.0)]) ** 2                   # measurement noise$/;"	v
R	extended_kalman_filter.py	/^R = np.diag([1.0, 1.0]) ** 2  # Observation x,y position covariance$/;"	v
R	start_localisation.py	/^R = np.diag([1, 2, np.pi\/180, 1]) ** 2                      # state covariance$/;"	v
Robot	myrobot.py	/^class Robot(object):$/;"	c
SIM_TIME	extended_kalman_filter.py	/^SIM_TIME = 50.0  # simulation time [s]$/;"	v
WORLD_SIZE	myrobot.py	/^    WORLD_SIZE = 100$/;"	v	class:Robot
X	start_localisation.py	/^X = np.array([2, 1, 0, 0])                                  # initial state$/;"	v
__init__	localise_ekf.py	/^    def __init__(self, Q, R, P):$/;"	m	class:EKF
__init__	myrobot.py	/^    def __init__(self, pose):$/;"	m	class:Robot
__set_map__	myrobot.py	/^    def __set_map__(cls, landmarks):$/;"	m	class:Robot	file:
advance	myrobot.py	/^    def advance(self, state, cmd, delta_t, noise):$/;"	m	class:Robot
calc_input	extended_kalman_filter.py	/^def calc_input():$/;"	f
delta_t	start_localisation.py	/^delta_t = 0.5$/;"	v
ekf_correction	start_localisation.py	/^def ekf_correction(x, P, u, y, delta_t):$/;"	f
ekf_est	start_localisation.py	/^def ekf_est(x, P, u, y, delta_t):$/;"	f
ekf_estimation	extended_kalman_filter.py	/^def ekf_estimation(xEst, PEst, z, u):$/;"	f
ekf_pr	start_localisation.py	/^def ekf_pr(x, Sigma, u, z, delta_t):$/;"	f
ex02_h	ex02_h.m	/^function [y, Y_x] = ex02_h(x) $/;"	f
f	ex02_h.m	/^function f() $/;"	f
jacob_easy	jacob_easy.m	/^function jacob_easy() $/;"	f
jacob_f	extended_kalman_filter.py	/^def jacob_f(x, u):$/;"	f
jacob_h	extended_kalman_filter.py	/^def jacob_h():$/;"	f
landmarks	start_localisation.py	/^landmarks = [[25.0, 30.0], [90.0, 80.0], [10.0, 80.0], [80.0, 10.0]]$/;"	v
line_est	start_localisation.py	/^line_est = []$/;"	v
line_particles	start_localisation.py	/^line_particles = []$/;"	v
line_path	start_localisation.py	/^line_path = []$/;"	v
line_true	start_localisation.py	/^line_true = []$/;"	v
main	extended_kalman_filter.py	/^def main():$/;"	f
motion_model	extended_kalman_filter.py	/^def motion_model(x, u):$/;"	f
motion_model	start_localisation.py	/^def motion_model(state, cmd, delta_t):$/;"	f
motion_update	myrobot.py	/^    def motion_update(self, x, y, phi):$/;"	m	class:Robot
move	myrobot.py	/^    def move(self, turn, forward):$/;"	m	class:Robot
myrobot	start_localisation.py	/^myrobot = Robot([2, 1, 0])$/;"	v
n	start_localisation.py	/^    n = np.random.normal(loc=0, scale=q, size=2)$/;"	v
obs	myrobot.py	/^    def obs(self, state):$/;"	m	class:Robot
observation	extended_kalman_filter.py	/^def observation(xTrue, xd, u):$/;"	f
observation_model	extended_kalman_filter.py	/^def observation_model(x):$/;"	f
observation_model	start_localisation.py	/^def observation_model(state):$/;"	f
p_act	start_localisation.py	/^p_act = []$/;"	v
p_pred	start_localisation.py	/^p_pred = []$/;"	v
p_x	start_localisation.py	/^p_x = list("")$/;"	v
p_y	start_localisation.py	/^p_y = list("")$/;"	v
path_actual	start_localisation.py	/^path_actual = []$/;"	v
plot_covariance_ellipse	extended_kalman_filter.py	/^def plot_covariance_ellipse(xEst, PEst):  # pragma: no cover$/;"	f
predict	localise_ekf.py	/^    def predict(self, ain):$/;"	m	class:EKF
predict	myrobot.py	/^    def predict(self, state, cmd, noise, delta_t):$/;"	m	class:Robot
pt_x	start_localisation.py	/^pt_x = list("")$/;"	v
pt_y	start_localisation.py	/^pt_y = list("")$/;"	v
q	start_localisation.py	/^q = np.sqrt(np.diag(Q)) \/ 2$/;"	v
r	start_localisation.py	/^r = np.sqrt(np.diag(R)) \/ 2$/;"	v
sense	myrobot.py	/^    def sense(self):$/;"	m	class:Robot
sense_linear	myrobot.py	/^    def sense_linear(self, state):$/;"	m	class:Robot
set_motion_cmd	myrobot.py	/^    def set_motion_cmd(self, turn, forward):$/;"	m	class:Robot
set_noise	myrobot.py	/^    def set_noise(self, turn_noise, forward_noise, sense_noise):$/;"	m	class:Robot
set_simulation_params	localise_ekf.py	/^    def set_simulation_params(self, delta_t):$/;"	m	class:EKF
show_animation	extended_kalman_filter.py	/^show_animation = True$/;"	v
u	start_localisation.py	/^        u = np.array([v, yaw_rate])$/;"	v
u	start_localisation.py	/^u = [0, 0]$/;"	v
ud	start_localisation.py	/^    ud = u + np.random.randn(2) * INPUT_NOISE  $/;"	v
v	start_localisation.py	/^        v = np.random.normal() * 5 + 2.5$/;"	v
x	start_localisation.py	/^x = np.array([3, 3, np.deg2rad(0.8), 0])   # initial state$/;"	v
yaw_rate	start_localisation.py	/^        yaw_rate = np.random.normal() * 0.3$/;"	v
